#  Copyright 2024 Google LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Utilities for working with shared data."""

import dataclasses
import json
from typing import Any, Sequence

from google3.pyglib import resources

_SHARED_DATA = resources.GetResourceFilename(
    'google3/wireless/android/platform/testing/bettertogether/betocq/all_shared_data.json'
)

_SHARED_DATA_TYPES = [
    'source',  # For Google3 data that is checked into source.
    'output',  # For Google3 data that is generated by a build rule.
]


@dataclasses.dataclass
class SharedData:
  """A container class for configuring partner-shared data."""

  target: str
  data_type: str
  blazerc: str
  flags: list[str]

  def build_command(self) -> list[str]:
    """Returns the command to build the data."""
    if self.data_type == 'source':
      raise ValueError('Source data is not built.')
    return (
        ['blaze', f'--blazerc={self.blazerc}', 'build']
        + self.flags
        + [
            self.target,
        ]
    )

  @classmethod
  def from_json(cls, json_data: dict[str, Any]) -> 'SharedData':
    """Parses a SharedData object from JSON configuration."""
    target = json_data['target']
    if not isinstance(target, str):
      raise ValueError(f'Target must be a string, got {type(target)}')
    data_type = json_data['data_type']
    if data_type not in _SHARED_DATA_TYPES:
      raise ValueError(
          f'Data type must be one of {_SHARED_DATA_TYPES}, got {data_type}'
      )
    blazerc = json_data['blazerc']
    if not isinstance(blazerc, str):
      raise ValueError(f'blazerc must be a string, got {type(blazerc)}')
    flags = json_data.get('flags', [])
    if not isinstance(flags, list):
      raise ValueError(f'Flags must be a list, got {type(flags)}')
    return cls(target, data_type, blazerc or '/dev/null', flags)


def shared_data_configs() -> Sequence[SharedData]:
  """Loads and parses all shared data configs."""
  results = []
  with open(_SHARED_DATA, 'r') as f:
    configs = json.load(f)
    for config in configs:
      results.append(SharedData.from_json(config))
    return results
